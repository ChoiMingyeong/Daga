/*! MarchingSquares.js - v1.3.1 - 2017-05-28
* https://github.com/RaumZeit/MarchingSquares.js
* Copyright (c) 2017 Stefan Goessner; MIT License */
(function (global) { var MarchingSquaresJS = {}; MarchingSquaresJS.VERSION = "1.3.1"; MarchingSquaresJS.isoLines = function (data, threshold, opt) { var square, rows = data.length, cols = data[0].length, result = [], line = [], x, y, i, a, b, w = opt && opt.weight || 0.5; if (rows < 2 || cols < 2) return result; for (y = 0; y < rows - 1; y++) { for (x = 0; x < cols - 1; x++) { square = 0; if (data[y][x] > threshold) square |= 1; if (data[y][x + 1] > threshold) square |= 2; if (data[y + 1][x + 1] > threshold) square |= 4; if (data[y + 1][x] > threshold) square |= 8; if (square === 0 || square === 15) continue; line = []; if ((square & 1) !== (square & 2)) line.push([x + w, y]); if ((square & 2) !== (square & 4)) line.push([x + 1, y + w]); if ((square & 4) !== (square & 8)) line.push([x + w, y + 1]); if ((square & 8) !== (square & 1)) line.push([x, y + w]); if (line.length === 2) result.push(line) } } return result }; MarchingSquaresJS.isoContours = function (data, threshold, opt) { var edgeTable = [0, 9, 3, 10, 6, 15, 5, 12, 12, 5, 15, 6, 10, 3, 9, 0], rows = data.length, cols = data[0].length, result = [], edge, l = 0, x = 0, y = 0, d = 0, a = 0, b = 0, p0, p1, w = opt && opt.weight || 0.5, addEdge = function (p0, p1) { var contour = [p0]; while (!equalPoints(p1, p0)) { contour.push(p1); var temp = p1; p1 = followEdge(p1, p0); p0 = temp } result.push({ index: l++, values: contour }) }, equalPoints = function (p1, p2) { return p1[0] === p2[0] && p1[1] === p2[1] }, followEdge = function (p0, p1) { var x = p1[0] | 0, y = p1[1] | 0, dir = edgeTable[data[y][x] > threshold | data[y][x + 1] > threshold << 1 | data[y + 1][x + 1] > threshold << 2 | data[y + 1][x] > threshold << 3]; if (dir === 0) return p1; if ((dir & 1) && !equalPoints(p0, [x + w, y])) return [x + w, y]; if ((dir & 2) && !equalPoints(p0, [x + 1, y + w])) return [x + 1, y + w]; if ((dir & 4) && !equalPoints(p0, [x + w, y + 1])) return [x + w, y + 1]; if ((dir & 8) && !equalPoints(p0, [x, y + w])) return [x, y + w]; return p1 }; for (y = 0; y < rows - 1; y++)for (x = 0; x < cols - 1; x++) { edge = 0; if (data[y][x] > threshold) edge |= 1; if (data[y][x + 1] > threshold) edge |= 2; if (data[y + 1][x + 1] > threshold) edge |= 4; if (data[y + 1][x] > threshold) edge |= 8; if (edge === 0 || edge === 15) continue; a = [x + w, y]; b = [x + 1, y + w]; if (edge & 1 && edge & 2) addEdge(a, b); a = [x + 1, y + w]; b = [x + w, y + 1]; if (edge & 2 && edge & 4) addEdge(a, b); a = [x + w, y + 1]; b = [x, y + w]; if (edge & 4 && edge & 8) addEdge(a, b); a = [x, y + w]; b = [x + w, y]; if (edge & 8 && edge & 1) addEdge(a, b) } return result }; typeof module !== "undefined" && module.exports && (module.exports = MarchingSquaresJS), typeof define === "function" && define.amd ? define([], function () { return MarchingSquaresJS }) : global.MarchingSquaresJS = MarchingSquaresJS })(this);